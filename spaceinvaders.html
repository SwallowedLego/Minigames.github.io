<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Invaders - MinPlay</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0ff;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      text-align: center;
    }

    canvas {
      border: 2px solid #0ff;
      background: linear-gradient(180deg, #000428 0%, #004e92 100%);
      box-shadow: 0 0 20px #0ff;
    }

    .game-ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #0ff;
      font-size: 18px;
      font-weight: bold;
      z-index: 10;
    }

    .controls {
      position: absolute;
      bottom: -60px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 14px;
      text-align: center;
      opacity: 0.8;
    }

    .game-over-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #0ff;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 100;
    }

    .game-over-screen h2 {
      color: #ff0080;
      font-size: 2rem;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #ff0080;
    }

    .game-over-screen p {
      color: #0ff;
      margin-bottom: 20px;
    }

    .restart-btn {
      padding: 12px 24px;
      background: transparent;
      color: #0ff;
      border: 2px solid #0ff;
      border-radius: 5px;
      cursor: pointer;
      font-family: inherit;
      font-size: 16px;
      margin: 5px;
      transition: all 0.3s ease;
    }

    .restart-btn:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 10px #0ff;
    }

    @media (max-width: 800px) {
      canvas {
        width: 100vw;
        height: 70vh;
      }
      .controls {
        bottom: 10px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <button class="back-btn" onclick="location.href='index.html'">← Back to Games</button>
  
  <div class="game-container">
    <div class="game-ui">
      <div>Score: <span id="score">0</span></div>
      <div>Level: <span id="level">1</span></div>
      <div>Lives: <span id="lives">3</span></div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
      Use A/D or ← → to move • SPACE to shoot • P to pause
    </div>
    
    <div class="game-over-screen" id="gameOverScreen">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverStats">Final Score: 0</p>
      <button class="restart-btn" onclick="restartGame()">Play Again</button>
      <button class="restart-btn" onclick="location.href='index.html'">Back to Games</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameRunning = true;
    let gamePaused = false;
    let score = 0;
    let level = 1;
    let lives = 3;

    // Player
    const player = {
      x: canvas.width / 2 - 25,
      y: canvas.height - 60,
      width: 50,
      height: 30,
      speed: 5,
      color: '#0ff'
    };

    // Game objects arrays
    let bullets = [];
    let invaders = [];
    let invaderBullets = [];
    let particles = [];

    // Game timing
    let lastTime = 0;
    let invaderDirection = 1;
    let invaderSpeed = 1;
    let invaderDropDistance = 40;

    // Input handling
    const keys = {};
    let lastShot = 0;
    const shotCooldown = 250; // milliseconds

    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      
      if (e.key === ' ') {
        e.preventDefault();
        shoot();
      }
      
      if (e.key.toLowerCase() === 'p') {
        togglePause();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Touch controls for mobile
    let touchStartX = 0;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchStartX = e.touches[0].clientX;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const rect = canvas.getBoundingClientRect();
      const canvasX = (touchX - rect.left) * (canvas.width / rect.width);
      player.x = Math.max(0, Math.min(canvas.width - player.width, canvasX - player.width / 2));
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      shoot();
    });

    function initInvaders() {
      invaders = [];
      const rows = 5;
      const cols = 10;
      const invaderWidth = 40;
      const invaderHeight = 30;
      const spacing = 10;
      const startX = (canvas.width - (cols * (invaderWidth + spacing))) / 2;
      const startY = 50;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          invaders.push({
            x: startX + col * (invaderWidth + spacing),
            y: startY + row * (invaderHeight + spacing),
            width: invaderWidth,
            height: invaderHeight,
            alive: true,
            type: row < 2 ? 'small' : row < 4 ? 'medium' : 'large',
            points: row < 2 ? 30 : row < 4 ? 20 : 10
          });
        }
      }
    }

    function shoot() {
      const now = Date.now();
      if (now - lastShot > shotCooldown) {
        bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 10,
          speed: 7,
          color: '#ff0080'
        });
        lastShot = now;
      }
    }

    function updatePlayer() {
      if (keys['a'] || keys['arrowleft']) {
        player.x = Math.max(0, player.x - player.speed);
      }
      if (keys['d'] || keys['arrowright']) {
        player.x = Math.min(canvas.width - player.width, player.x + player.speed);
      }
    }

    function updateBullets() {
      // Update player bullets
      bullets = bullets.filter(bullet => {
        bullet.y -= bullet.speed;
        return bullet.y > -bullet.height;
      });

      // Update invader bullets
      invaderBullets = invaderBullets.filter(bullet => {
        bullet.y += bullet.speed;
        return bullet.y < canvas.height;
      });
    }

    function updateInvaders() {
      let moveDown = false;
      const aliveInvaders = invaders.filter(inv => inv.alive);
      
      if (aliveInvaders.length === 0) {
        nextLevel();
        return;
      }

      // Check if invaders need to change direction
      const leftmost = Math.min(...aliveInvaders.map(inv => inv.x));
      const rightmost = Math.max(...aliveInvaders.map(inv => inv.x + inv.width));

      if (rightmost >= canvas.width - 10 || leftmost <= 10) {
        moveDown = true;
        invaderDirection *= -1;
      }

      // Move invaders
      aliveInvaders.forEach(invader => {
        if (moveDown) {
          invader.y += invaderDropDistance;
        }
        invader.x += invaderDirection * invaderSpeed;

        // Invader shooting (random)
        if (Math.random() < 0.0003 * level) {
          invaderBullets.push({
            x: invader.x + invader.width / 2 - 2,
            y: invader.y + invader.height,
            width: 4,
            height: 8,
            speed: 3,
            color: '#ff4444'
          });
        }
      });

      // Check if invaders reached player
      if (aliveInvaders.some(inv => inv.y + inv.height >= player.y)) {
        gameOver();
      }
    }

    function checkCollisions() {
      // Bullet vs Invader collisions
      bullets.forEach((bullet, bulletIndex) => {
        invaders.forEach((invader, invaderIndex) => {
          if (invader.alive &&
              bullet.x < invader.x + invader.width &&
              bullet.x + bullet.width > invader.x &&
              bullet.y < invader.y + invader.height &&
              bullet.y + bullet.height > invader.y) {
            
            // Create explosion particles
            createExplosion(invader.x + invader.width / 2, invader.y + invader.height / 2);
            
            invader.alive = false;
            bullets.splice(bulletIndex, 1);
            score += invader.points;
            updateUI();
          }
        });
      });

      // Invader bullet vs Player collision
      invaderBullets.forEach((bullet, bulletIndex) => {
        if (bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
          
          invaderBullets.splice(bulletIndex, 1);
          lives--;
          updateUI();
          
          if (lives <= 0) {
            gameOver();
          } else {
            // Create player hit effect
            createExplosion(player.x + player.width / 2, player.y + player.height / 2);
          }
        }
      });
    }

    function createExplosion(x, y) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 30,
          maxLife: 30,
          color: `hsl(${Math.random() * 60 + 15}, 100%, 60%)`
        });
      }
    }

    function updateParticles() {
      particles = particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        return particle.life > 0;
      });
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = 'rgba(0, 4, 40, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw stars background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      for (let i = 0; i < 100; i++) {
        const x = (i * 17 + Date.now() * 0.01) % canvas.width;
        const y = (i * 13 + Date.now() * 0.02) % canvas.height;
        ctx.fillRect(x, y, 1, 1);
      }

      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Draw player cannon
      ctx.fillRect(player.x + player.width / 2 - 3, player.y - 10, 6, 10);

      // Draw bullets
      bullets.forEach(bullet => {
        ctx.fillStyle = bullet.color;
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        
        // Add glow effect
        ctx.shadowColor = bullet.color;
        ctx.shadowBlur = 10;
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        ctx.shadowBlur = 0;
      });

      // Draw invader bullets
      invaderBullets.forEach(bullet => {
        ctx.fillStyle = bullet.color;
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });

      // Draw invaders
      invaders.forEach(invader => {
        if (invader.alive) {
          ctx.fillStyle = invader.type === 'small' ? '#ff0080' : 
                         invader.type === 'medium' ? '#00ff80' : '#0080ff';
          ctx.fillRect(invader.x, invader.y, invader.width, invader.height);
          
          // Draw invader details
          ctx.fillStyle = '#fff';
          ctx.fillRect(invader.x + 5, invader.y + 5, 5, 5);
          ctx.fillRect(invader.x + invader.width - 10, invader.y + 5, 5, 5);
        }
      });

      // Draw particles
      particles.forEach(particle => {
        const alpha = particle.life / particle.maxLife;
        ctx.fillStyle = particle.color.replace('60%)', `60%, ${alpha})`);
        ctx.fillRect(particle.x, particle.y, 3, 3);
      });

      // Draw pause overlay
      if (gamePaused) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#0ff';
        ctx.font = '48px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
        ctx.fillText('Press P to continue', canvas.width / 2, canvas.height / 2 + 60);
      }
    }

    function gameLoop(timestamp) {
      if (!gameRunning) return;
      
      if (!gamePaused) {
        updatePlayer();
        updateBullets();
        updateInvaders();
        updateParticles();
        checkCollisions();
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }

    function nextLevel() {
      level++;
      invaderSpeed += 0.5;
      updateUI();
      initInvaders();
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('gameOverTitle').textContent = 'Game Over';
      document.getElementById('gameOverStats').textContent = `Final Score: ${score} | Level: ${level}`;
      document.getElementById('gameOverScreen').style.display = 'block';
    }

    function togglePause() {
      gamePaused = !gamePaused;
    }

    function restartGame() {
      gameRunning = true;
      gamePaused = false;
      score = 0;
      level = 1;
      lives = 3;
      invaderSpeed = 1;
      
      bullets = [];
      invaderBullets = [];
      particles = [];
      
      player.x = canvas.width / 2 - 25;
      
      updateUI();
      initInvaders();
      document.getElementById('gameOverScreen').style.display = 'none';
      gameLoop();
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lives').textContent = lives;
    }

    // Initialize and start game
    updateUI();
    initInvaders();
    gameLoop();
  </script>
</body>
</html>